import pandas as pd
import numpy as np
import math
import copy
'''Coded by Baihan Huang (2089692)
This code optimizes the passenger flow prediction
'''
data = pd.read_excel('input-TwoHour-wupian-duibihou.xlsx')
print(data)
pp=0
original = data.iloc[0, pp:]
predicted = data.iloc[1, pp:]
original = np.array(original)
predicted = np.array(predicted)
num = len(original)
def judgeMarkov(xij, p_j, fij):
    kafang = 0
    for i in range(3):
        for j in range(3):
            if(xij[i][j] > 0):
                kafang += fij[i,j] * abs(math.log(xij[i,j] / p_j[j]))
                print(kafang)
    kafang *= 2
    print(kafang)
    # confidence coefficient 95%
    if kafang > 9.488:
    # confidence coefficient 90%
    # if kafang > 7.779:
        return True
    else:
        return False
def getGroup(diff):
    mean = np.mean(diff)   # get the mean value of the diff
    std = np.std(diff)   # get the standard deviation
    grouped = np.zeros(len(diff))   # get zero matrix according to the length of diff
    diff3 = (max(diff) - min(diff)) / 3
    mmin = min(diff)   # get the minumum of diff
    mmax = max(diff)
    print(mmin)
    print(mmax)   # get the maxumum of diff
    print(diff)
    print(mean, std)
    print(mean-std,mean,mean+std)
    useMessage = "3equal"   # This can control which grouping method is used
    # 3 Equal division
    if useMessage == '3equal':
        grouped[np.where((diff >= mmin) & (diff <= mmin + diff3))] = 1   # group diff, np.where will output indexes which meet the criteria
        grouped[np.where((diff > mmin + diff3) & (diff < mmin + diff3 * 2))] = 2   # Then, the corresponding position will be given a state
        grouped[np.where((diff >= mmin + diff3 * 2) & (diff <= mmax))] = 3
    # elif useMessage == 'withStd':
    #
        #grouped[np.where((diff >= mean-2*std) & (diff <= mean - std))] = 1
        #grouped[np.where((diff > mean-std) & (diff < mean + std))] = 2
        #grouped[np.where((diff >= mean+std) & (diff <= mean + 2*std))] = 3
    elif useMessage == 'withStdInf':
    # Sample mean-mean square error
        grouped[np.where(diff <= mean - std)] = 1
        grouped[np.where((diff > mean-std) & (diff < mean + std))] = 2
        grouped[np.where(diff >= mean+std)] = 3
    # The grouped contains the index of every elements
    print(grouped)
# for example
#number   1 1 3 4 5 6 7 8
#state    1 1 1 2 2 3 3 3
# 0 1 2
# 0 0 0 0
# 1 0 0 0
# 2 0 0 0
    pij = np.zeros((3,3))   # This is creating a n*n zero matrix
    for i in range(len(grouped)-1): # Obtain the total number of grouded.The reason about minus 1 is because range starts at 0
        pij[int(grouped[i]-1),int(grouped[i+1]-1)] += 1
    print(pij)
    # pij is the frequency from row i to column j
    # print(pij)
    # fij is also frequency
    fij = copy.deepcopy(pij)
    # calculate marginal probability, p_j
    p_j = np.zeros(3)
    for i in range(3):
        p_j[i] = sum(pij[:, i]) / sum(sum(pij))
    print(p_j)
    # calculate transfer probability
    xij = np.zeros((3,3))
    for i in range(3):
        # Prevent the denominator from being zero
        if(sum(pij[i,:])):
            for j in range(3):
                xij[i,j] = pij[i,j] / sum(pij[i,:])
    print(xij)
    # Calculate the average value of the maximum and minimum values of the groups
    delta = np.zeros(3)
    for i in range(1,4):
        groupedDiff = diff[np.where(grouped == i)]
        # Prevent the occurrence of zero elements
        if(len(groupedDiff) > 0):
            if useMessage == 'withStdInf':
                if(i == 2):
                    delta[1] = mean
                elif i == 1:
                    delta[0] = (min(groupedDiff) + mean - std) / 2
                elif i == 3:
                    delta[2] = (max(groupedDiff) + mean + std) / 2
            elif useMessage == 'withStd':
                if(i == 2):
                    delta[1] = mean
                elif i == 1:
                    delta[0] = mean - std * 1.5
                elif i == 3:
                    delta[2] = mean + std * 1.5
            elif useMessage == '3equal':
                if i == 1:
                    delta[0] = mmin + diff3 / 2
                elif i == 2:
                    delta[1] = mmin + diff3 * 1.5
                elif i == 3:
                    delta[2] = mmin + diff3 * 2.5
                print(delta)
            #delta[i-1] = (min(groupedDiff) + max(groupedDiff)) / 2
# Determine whether Markov property is satisfied
flagMarkov = judgeMarkov(xij, p_j, fij)
if(flagMarkov):
    print("True")
    return_delta = 0
    lastGroupId = grouped[len(diff) - 1]
    for i in range(3):
        return_delta += delta[i] * xij[int(lastGroupId-1), i]
    print(return_delta)
    return return_delta
else:
    print("False")
    return 0
eachGroupNumber = 8
beforePredict = copy.deepcopy(predicted)
trueNum = 0
# This is the correction value
times = np.array(data.columns)
print(times)
for i in range(num-eachGroupNumber):
    print()
    print(times[i:i+eachGroupNumber])
    eachOri = original[i:i+eachGroupNumber]
    eachPre = predicted[i:i+eachGroupNumber]
    print(eachOri)
    print(eachPre)
    diff = eachOri - eachPre
    delta = getGroup(diff)
    if(delta != 0):
        trueNum += 1
    predicted[i+eachGroupNumber] += delta

output = copy.deepcopy(data)
markovRevised = copy.deepcopy(predicted)
print(data.columns[pp:])
markovDafaFrame = pd.DataFrame([original, beforePredict, markovRevised],columns=data.columns[pp:])
output = pd.concat([output, markovDafaFrame]).reset_index(drop=True)
markovDafaFrame.to_excel('output2-3q-12num-15mins-new-TowHour-sanjie-wupian(1).xlsx')
print('\n\n')

predicted = copy.deepcopy(beforePredict)
# This is the half correction value
times = np.array(data.columns)
print(times)
for i in range(num-eachGroupNumber):
    print()
    print(times[i:i+eachGroupNumber])
    eachOri = original[i:i+eachGroupNumber]
    eachPre = predicted[i:i+eachGroupNumber]
    diff = eachOri - eachPre
    delta = getGroup(diff)
    predicted[i+eachGroupNumber] += delta / 2
markovRevised_half = copy.deepcopy(predicted)
markovDafaFrame2 = pd.DataFrame([original, beforePredict, markovRevised, markovRevised_half],columns=data.columns[pp:])
markovDafaFrame2.to_excel('output3-3q-8num-15mins-new-TowHour-sanjie-wupian.xlsx')
print('true num : ', trueNum)
