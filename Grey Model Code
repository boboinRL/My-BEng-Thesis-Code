import numpy as np
import pandas as pd
import math

# ===================================================================
# Python Version of Grey Model Prediction
# Translated from MATLAB
# ===================================================================

def gm11_prediction():
    # 1. 读取数据 (Read Data)
    # 注意：Matlab中xlsread默认读取数值矩阵。
    # 这里假设Excel没有表头，或者第2行(Index 1)是数据。
    # Matlab: m(2, ...) -> Python: df.iloc[1, ...]
    try:
        # header=None 假设没有表头，根据你的实际文件情况调整
        df_raw = pd.read_excel('station1.xlsx', header=None)
        m = df_raw.values # 转换为numpy数组
    except FileNotFoundError:
        print("错误: 未找到 station1.xlsx 文件。")
        return

    # 准备存储列表
    data_all_G = [] # 对应 Matlab 的 data
    data_e = []     # 对应 Matlab 的 data1 (后验差比值)
    p_preds = []    # 对应 Matlab 的 p (第9个预测值)

    # Matlab: C=m(2,23+8+2:86+8+2);
    # 索引计算: 23+8+2=33, 86+8+2=96. Matlab是1-based且包含结尾.
    # Python是0-based且不包含切片结尾.
    # Col 33 (Matlab) -> Index 32 (Python)
    # Col 96 (Matlab) -> Index 95 (Python). 切片需写到 96.
    C_truth = m[1, 32:96] 

    # 2. 循环处理 (Main Loop)
    # Matlab: for t=23:86
    # Python range is start inclusive, stop exclusive
    loop_start = 23
    loop_end = 87 
    
    col_idx_offset = 2 # 对应 Matlab 代码中的 +2 偏移量

    for t in range(loop_start, loop_end):
        startTime = t
        endTime = t + 7
        
        # 提取数据切片 d
        # Matlab: m(2, startTime+2 : endTime+2)
        # 长度为 8 (endTime - startTime + 1 ? No, t to t+7 is 8 points)
        slice_start = startTime + col_idx_offset - 1 # -1 for 0-based
        slice_end = endTime + col_idx_offset # Python slice end is exclusive, so no -1
        
        d = m[1, slice_start:slice_end]
        A = d.astype(float).copy() # 确保是浮点数并复制
        n = len(A)

        # 3. 数据平滑处理 (3-point moving average)
        # Matlab loop: for i=2:(n-1) -> A(i)=(A(i+1)+A(i)+A(i-1))/3
        # 注意：要在原始数据上滑动，还是在更新后的数据上？
        # Matlab代码逻辑是迭代更新的 (Usually bad practice but we follow source logic)
        # 原代码: A(i) 被赋值，下一次循环用到的是新的 A(i)。
        for i in range(1, n-1): # Python index 1 to n-2
            A[i] = (A[i+1] + A[i] + A[i-1]) / 3.0

        # 4. 累加生成 (AGO)
        B = np.cumsum(A)

        # 5. 紧邻均值生成 (Mean Generating Operation)
        X = np.zeros(n-1)
        for i in range(n-1):
            X[i] = (B[i] + B[i+1]) / 2.0

        # 6. 最小二乘法求参数 a, u (Least Square Method)
        # D is Y, E is B matrix
        D = A[1:].reshape(-1, 1) # 去掉第一个元素，转为列向量
        
        # E = [-X, ones]
        E = np.vstack([-X, np.ones(n-1)]).T
        
        # c = inv(E*E')*E*D -> (E.T @ E)^-1 @ E.T @ D
        # 使用 pinv (伪逆) 增加稳定性，或者 lstsq
        try:
            c = np.linalg.inv(E.T @ E) @ E.T @ D
            a = c[0][0]
            u = c[1][0]
        except np.linalg.LinAlgError:
            print(f"矩阵奇异，跳过 t={t}")
            continue

        # 7. 预测模型 (Prediction Equation)
        # F(k+1) = (x(0) - u/a) * exp(-a*k) + u/a
        F = np.zeros(n + 1)
        F[0] = A[0]
        
        # Matlab循环: 2 to n+1. Python indices: 1 to n
        # 公式中的 i 对应 Matlab 的 i (从1开始算的时间点)
        for k in range(1, n + 1):
            # Matlab公式: (A(1)-u/a)/exp(a*(i-1))+u/a
            # 这里 k 对应 Matlab 的 i-1 (因为Python 0-based, Matlab loop i=2 corresponds to time step 1)
            F[k] = (A[0] - u/a) / np.exp(a * k) + u/a

        # 8. 累减还原 (IAGO)
        G = np.zeros(n + 1)
        G[0] = A[0]
        for i in range(1, n + 1):
            G[i] = F[i] - F[i-1]

        # 存储 G (作为列向量存入矩阵)
        data_all_G.append(G)

        # 9. 后验差检验 (Posterior difference test)
        # 截取 G 的前 n 个点与 A 比较 (Matlab代码逻辑)
        G_fit = G[:n] # 拟合部分
        
        # 残差
        Err = A - G_fit
        # 相对误差 (代码里算了但没存)
        # err_rel = Err / A 

        # 计算方差 S1 (原始数据方差)
        avg_A = np.mean(A)
        s1 = np.sqrt(np.sum((A - avg_A)**2) / (n - 1))

        # 计算方差 S2 (残差方差)
        avg_Err = np.mean(Err) # Matlab代码中: sumce/(n), 此处要注意Matlab是否除以了n或n-1
        # Matlab代码: ce = sum(Err)/n; s2 = sqrt(sum((Err - ce).^2) / (n-1))
        # 严格复刻 Matlab 逻辑:
        ce = np.sum(A - G_fit) / n
        s2 = np.sqrt(np.sum((A - G_fit - ce)**2) / (n - 1))

        e_ratio = s2 / s1
        # disp(['Posterior difference test is：', str(e_ratio)]) # 可选打印
        
        data_e.append(e_ratio)
        p_preds.append(G[8]) # Matlab G(9) -> Python Index 8

    # ===================================================================
    # 结果输出与误差计算
    # ===================================================================
    
    # 转换列表为矩阵 (转置以匹配 Matlab 的列添加方式)
    # Matlab data is [G1, G2, ...]
    data_matrix = np.array(data_all_G).T 
    data_e_matrix = np.array(data_e).reshape(1, -1)
    p_matrix = np.array(p_preds).reshape(1, -1)

    print("计算完成。正在写入 Excel...")

    # 写入 Excel
    # Matlab 写入了三个区域。Python Pandas 通常一次写入一个 Sheet。
    # 为了复刻结构，我们创建一个大的 DataFrame 或使用 ExcelWriter
    output_file = 'station-111-prediction-OnlyNext15min1_py.xlsx'
    
    with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
        # 写入 G 矩阵 (A1 start)
        pd.DataFrame(data_matrix).to_excel(writer, startrow=0, startcol=0, index=False, header=False)
        # 写入 e 比值 (A11 start -> row index 10)
        pd.DataFrame(data_e_matrix).to_excel(writer, startrow=10, startcol=0, index=False, header=False)
        # 写入 p 预测值 (A13 start -> row index 12)
        pd.DataFrame(p_matrix).to_excel(writer, startrow=12, startcol=0, index=False, header=False)

    print(f"数据已写入 {output_file}")

    # ===================================================================
    # RMSE 和 RME 计算
    # ===================================================================
    
    n_G = data_matrix.shape[1] # 列数
    
    # Matlab 逻辑:
    # 循环比较 C(i) 和 data(j, i) 其中 j=9 (Python index 8)
    # 注意: Matlab C 取的是真实值
    
    predictions = data_matrix[8, :] # 第9行 (Index 8) 是预测的下一个时刻的值
    
    # 确保长度一致
    min_len = min(len(C_truth), len(predictions))
    C_truth = C_truth[:min_len]
    predictions = predictions[:min_len]
    
    errors = C_truth - predictions
    
    # RMSE
    rmse = np.sqrt(np.mean(errors**2))
    print(f"Rmse: {rmse}")
    
    # Rme (平均相对误差绝对值之和?)
    # Matlab: sum_me = sum_me + (abs(Err)/C(i)); Rme = sum_me/n_G
    # 即 Mean Absolute Percentage Error (MAPE) 的变种
    rme = np.mean(np.abs(errors) / C_truth)
    print(f"Rme: {rme}")

if __name__ == "__main__":
    gm11_prediction()
